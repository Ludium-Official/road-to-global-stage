# 네트워크와 합의

## 0. Safety와 Liveness 
분산 시스템에서 쓰이는 합의 알고리즘이 네트워크에서 일관성을 유지하며 통용되기 위해 필요한 속성을 Safety, Liveness라고 한다:
- Safety는 나쁜 일이 발생해서는 안되는 속성을 뜻한다. 합의된 결과는 모두에게 일관되게 보여져야 하고 변하지 않는다. 블록체인의 finality와 동일한 개념으로 봐도 된다.
- Liveness는 좋은 일이 발생해야만 하는 속성을 뜻한다. 블록체인 비동기 네트워크 내에서 반드시 합의가 이루어져야 한다.

### FLP Impossibility
그렇다면 Safety와 Liveness를 모두 충족하는 합의 알고리즘은 존재할 수 있을까? 1985년 'Impossibility of Distributed Consensus with One Faulty Process’ 논문에서 FLP Impossibility 결과를 도출해낸다. FLP는 논문 저자들의 앞글자를 따온 약자이다. 여기서 다룬 증명은 다음과 같이 귀류법을 통해 이뤄진다:
- 한 가지 결함이 있는 노드가 있는 경우에 Safety와 Liveness를 모두 만족하는 완전한 합의를 이룰 수 있다고 가정한 다음에 이에 대한 모순을 도출해낸다.
- 수신한 메시지에 따라 영구적으로 state를 전환하는 state machine이 있을 때, 메시지 수신 지연이 네트워크 지연에 의한 것인지 장애에 의한 것인지 알 수 없다. 그래서 계속 state를 변경하여 합의에 도달하지 못하는 상황이 발생하여 무한 실행이 이뤄진다.
- 그러므로, '한 가지 결함이 있는 노드가 있는 경우에 Safety와 Liveness를 모두 만족하는 완전한 합의를 이룰 수 있다'는 가정은 모순이 된다.
- 따라서, 비동기 네트워크에서는 Safety와 Liveness를 모두 만족하는 합의 알고리즘을 설계하는 것이 불가능함을 알 수 있다.

이러한 증명은 비동기 네트워크로 구성된 블록체인과 같은 분산 시스템 구조에서 합의 알고리즘을 설계하려면 Safety와 Liveness 사이에서 균형을 맞춰야 함을 의미한다. 이는 마치 두 가지 상반된 목표를 동시에 달성하려는 줄다리기와 같다. 이 균형을 잘 맞추는 것이 분산시스템 합의 알고리즘 핵심 과제 중 하나이다.

## 1. PBFT (Practical Byzantine Fault Tolerance)
1999년도에 제안된 PBFT 알고리즘은 비잔틴 장군 문제를 해결하여 BFT 알고리즘으로 실용적으로 고안해내었다. 비동기 네트워크간의 불확실한 커뮤니케이션 문제를 어느정도 해소하였고, 결정론적인 Saftey를 확보했다는 점에서 현재 많은 분산 시스템의 합의 방식으로 사용되고 있다. 본 논문에서는 뷰 변경 프로토콜, 3단계 프로토콜, 다수결 합의 시스템 등을 통해 어떻게 문제를 풀어나갔는지 설명한다. 
- Safety: 3단계 프로토콜(Pre-Prepare, Prepare, Commit)과 2/3 다수결 합의 시스템을 통해 최악의 비잔틴 상황에서도 올바른 합의에 도달할 수 있는 Safety를 보장한다.
- Liveness: 뷰 변경 프로토콜과 같은 기능으로 네트워크 지연과 노드의 장애에도 불구하고 합의를 이루고 정상적으로 동작함으로써 Liveness를 보장한다. 그러나 긴 지연이 발생하면 Liveness를 완전하게 보장한다고 할 수는 없어서 Liveness는 일부 희생한다고 보면 된다.

그러나 몇 단계 투표를 거쳐서 그만큼 높은 네트워크 통신을 요구한다는 단점이 있기 떄문에 노드가 추가될 수록 통신량이 급격히 증가하여 누구나 참여할 수 있는 블록체인에는 어울리지 않았다. 또한, 분산 시스템의 주류는 중앙화된 집단에 의해 운영되었기 때문에 다른 분야에서도 채택되어 사용되기에는 다소 무리가 있어서 실제 사용되는 사례는 드물었다. 


### 합의에 필요한 최소 노드 수: 3f+1 
최적은 복원력을 갖기 위해서 최소 3f+1개 노드가 있어야 비동기 시스템에서 safety와 liveness을 유지할 수 있다. f는 결함이 있는 복제본을 처리하는 데 필요한 최소 복제본 수이다. 이는 텐더민트 합의 최소 검증자 수에도 관통하는 내용이다. 비잔틴 상황에서 실패할 수 있는 경우는 두 가지이다:
1. $f_1$: 메시지를 보내지 않는 결함이 있는 노드
2. $f_2$: 악의적으로 잘못된 메시지를 보내는 비잔틴 노드

이 두 가지 경우($f_1$, $f_2$)를 모두 포함한 결함 노드를 $f$ 라고 하자. 전체의 노드 수가 $n$이라고 할때, 정상적인 합의를 위해 필요한 최소 노드 수를 계산해야 한다: 
- 정상 노드 수: $n - f$
- 정상 노드가 결함 노드보다 많아야 하므로 $n - f > f$, 즉 $n > 2f$ 이 되어야 한다. 
- 악의적 메시지를 보내는 노드 수보다 정상 노드 수가 많아야 하므로 $n - f > f$, 즉 $n > 3f$ 이 되어야 한다. 

따라서, 정상적인 합의를 위해서는 필요한 총 노드 수는 $n > 3f$이므로, 최소 $3f + 1$ 개의 노드가 필요하다. 이 경우 결함 노드의 최대 수는 $f$가 된다.

## 2. PoW (Proof of Work)
2008년 사토시 나카모토가 공개한 'Bitcoin: A Peer-to-Peer Electronic Cash System' 문서에는 재밌는 내용들이 담겨져 있다. 이 문서에는 P2P 기반 전자 화폐 시스템의 설계도가 담겨 있었으며, 나카모토가 제시한 합의 알고리즘은 기존 합의 알고리즘과는 다른 방식으로 Safety와 Liveness의 밸런스를 맞추었다.

기존의 중앙화된 시스템은 특정 목적을 달성하기 위해 자체적으로 구동되는 경우가 대부분이었기 때문에, 비동기 네트워크 환경에서 장애나 결함으로 인해 발생하는 생존성 문제만 고민하면 되었다. 그러나 비트코인의 등장으로 인해 이론적으로만 논의되던 비잔틴 장군 문제를 실제로 해결해야 하는 상황이 발생했다.

비트코인과 같은 탈중앙화된 분산 원장 시스템은 누구나 참여할 수 있지만, 동시에 누구나 참여하지 않을 수도 있으며, 참여자의 정직성을 보장할 방법도 고민해야 한다.
- (탈중앙성) 누구나 참여할 수 있지만 누구나 참여하지 않을 수 있다
- (고신뢰성) 누구나 참여할 수 있기 때문에 수 많은 참여자 중 악의적인 참여자를 식별하여 활동을 제한해야 한다.

비트코인은 BFT 합의 알고리즘을 전 세계적으로 구동시킨 최초의 분산 시스템이다. 이론적으로는 PBFT(Practical Byzantine Fault Tolerance)가 BFT 문제 해결을 먼저 제시했지만, 이를 실제로 작동하도록 구현한 것은 비트코인이 처음이었다.

### 인센티브 시스템
PoW 합의 알고리즘에서 인센티브 경제는 채굴자들이 지속적으로 네트워크에 참여하도록 유도하여 네트워크의 Liveness를 보장한다. 블록 보상과 거래 수수료는 채굴자들에게 중요한 경제적 동기를 제공하며, 이는 네트워크의 지속성과 안전성을 유지하는 데 핵심적인 역할을 한다. 
- 블록 보상: 채굴 연산을 통해 블록 생성을 하면 첫 거래에 비트코인 토큰을 얻는다.
- 거래 수수료: 블록에 담을 트랜잭션을 검증하고 그 트랜잭션에서 발생한 수수료를 얻는다.

### The Longest Chain
PoW는 기본적으로 CPU 당 1표의 투표권을 갖는다고 볼 수 있다. 합리적인 참여자들은 긴 체인에 투표를 할 것이다. 그래서 많은 PoW가 투입된 가장 긴 체인이 대표로 선정된다. 
- 이전 블록(과거 거래 정보)을 변경하기 위해서는 공격자는 그 블록과 뒤를 잇는 모든 블록의 작업증명을 재수행해야하고 그러면서 뒤를 잇는 모든 블록을 따라잡아 앞질러야 한다.
- 시간이 지날수록 노드를 구동하는 하드웨어 발전과 변화하는 관여도를 보상하기 위해, 작업 증명 난이도는 시간당 평균 블록 수에 따른 평균 목표치를 조정해 결정된다.블록이 너무 빠르게 생성된다면 난이도는 증가한다.