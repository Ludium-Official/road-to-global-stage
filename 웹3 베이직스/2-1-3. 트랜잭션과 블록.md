# 트랜잭션과 블록
블록체인은 분산 서버 클라이언트 네트워크로 동일한 클라이언트에 요청, 처리된 데이터를 공유하는 노드들의 집합으로 구성되어 있다. 이처럼 요청, 처리된 데이터를 블록체인의 트랙잭션이라고 부른다. 블록체인 네트워크는 특정 시간 동안 처리된 트랜잭션 데이터를 하나의 단위로 저장하는데 이를 블록이라고 부른다.

## 트랜잭션
### 트랜잭션의 정의
트랜잭션은 블록체인 네트워크에 요청, 처리된 모든 데이터를 의미한다. 예를 들어 A가 B에게 토큰을 전송할 때에도, 아니면 블록체인에 저장된 특정 프로그램(ex. 스마트 컨트랙트)를 호출하여 기능을 구동할 때도 트랜잭션 처리가 발생한다. 처리된 트랜잭션은 단위 시간마다 블록체인에 블록 단위로 저장되는데 이처럼 체인에 저장된 데이터를 온체인 데이터라고 부른다. 
### 트랜잭션의 구성 요소
기본적으로 트랜잭션은 다음의 값을 포함한다.
1. 보내는 주소: 트랜잭션 처리를 요청하는 송신자(Sender) 주소
2. 받는 주소: 트랜잭션 처리의 영향을 받는 수신자(Receiver) 주소
3. 서명: 트랜잭션을 보내는 주소의 디지털 서명
4. 내용: 트랜잭션 처리 요청 내역
5. 수수료: 트랜잭션 처리를 위해 지불하는 비용

### 트랜잭션의 구동 원리
트랜잭션의 생성에서 체인 반영까지는 다음과 같은 
1. 송신자 처리 요청: 트랜잭션 처리를 원하는 송신자가 자신의 로컬 환경에서 트랜잭션을 생성하고 처리를 요청한다. 이 때 송신자는 트랜잭션 전파가 가능한 RPC(Remote Procedure Call) 노드와 소통한다
2. 네트워크 전파: 트랜잭션을 전송 받은 노드는 인근 노드에게 트랜잭션을 전파한다. 이를 통해 트랜잭션이 네트워크 전채에 전파된다. 트랜잭션이 반영되기 전 노드에 저장되는 곳을 멤풀(Mempool)이라 부른다 
3. 트랜잭션 결과 반영: 노드에 전파된 트랜잭션이 단위 시간마다 블록의 형태로 검증, 저장된다. 트랜잭션이 블록에 저장되기 위해서는 트랜잭션의 유효성에 기반해 노드들의 합의 과정이 수반된다
4. 블록 전파: 블록으로 합의된 데이터를 네트워크에 전파한다. 네트워크에 참여하는 모든 노드들은 전파된 블록 데이터에 기반해 공동 원장을 공유한다

## 블록
### 블록과 체인

블록은 블록 체인에 추가된 새로운 트랜잭션의 기록이다. 새로운 트랜잭션(기록)을 블록(장부)에 담는다고 표현할 수 있다. 각 블록에는 다른 블록과 구별할 수 있는 고유한 코드와 이전 블록의 해시가 포함되어 블록을 연결한다. 이렇게 서로 연결되어 위변조 할 수 없는 안전한 체인이 형성되는 것이다. 네트워크가 온라인 상태가 된 후 채굴 된 첫 번째 블록을 제네시스 블록(genesis block)이라 하고 이를 포함하여 함께 연결된 모든 블록들을 일컬어 블록 체인 이라고 부른다. 체인은 네트워크 내 모든 트랜잭션을 포함해 모든 계정의 잔고를 기록하는 장부, 즉 원장이라고 할 수 있다.

### 블록의 구성 요소
블록은 다음의 내요을 포함한다.
1. 이전 블록 정보: 블록체이는 이전 블록의 해시 값과 같이 이전 블록의 데이터를 검증할 수 있는 값을 포함한다. 이를 통해 이후 블록에 지금까지 생성된 모든 데이터가 연결된 형태로(체인으로) 저장된다
2. 트랜잭션 데이터: 이번 블록에 저장될 트랜잭션의 데이터이다. 특정 시간 동안 네트워크에 전파된 유효 트랜잭션을 포함한다
3. 블록 넘버: 블록이 생성된 순서를 표시한다. 최초 블록은 0번이고 그 이후부터 번호가 적용횐다    
4. 타임스탬프: 블록이 생성된 시각이다. 최초 생성 시점으로부터 매번 블록이 생성될 때마다의 시간(초)가 추가된다. 예를 들어 블록 생성에 걸리는 시간이 12초이고 3번째 블록이라면 36이 된다 
5. 블록 생성자 서명: 블록의 데이터를 검증하고 생산을 최종 승인한 채굴자 혹은 검증자의 서명이다. 합의 알고리즘에 따라 생성자가 지정되며 서명을 하면 블록 생산에 대한 보상을 받을 수 있다

### 블록과 블록의 작동방식

이더리움 네트워크의 모든 참가자가 동기화 된 상태를 유지하고 정확한 트랜잭션 내역에 동의하도록 하기 위해, 트랜잭션을 블록에 담아 일괄처리 한다. 수십 또는 수백개의 트랜잭션이 한 번에 커밋되고, 합의되고,동기화 된다는 것을 의미한다. 또한 트랜잭션의 크기는 제각각이고, 블록은 트랜잭션의 수가 아니라 블록에 포함될 트랜잭션이 소비할 수 있는 최대 가스량에 의해 정해진다. 다시 말해, 블록 당 저장되는 데이터의 최대량은 정해져 있다.

![출처 : [https://ethereum.org/ko/developers/docs/blocks/](https://ethereum.org/ko/developers/docs/blocks/)](./images/블록구조-1.png)

출처 : [https://ethereum.org/ko/developers/docs/blocks/](https://ethereum.org/ko/developers/docs/blocks/)

사용자가 트랜잭션을 요청하면 트랜잭션을 받은 노드들은 자신에게 설치된 클라이언트를 통해 유효성을 확인한다. 해당 트랜잭션이 유효하면 멤풀(Mempool, Memory pool)이란 보류중인 트랜잭션이 모인 공간에 추가되고 검증자들은 해당 트랜잭션들 중 수수료가 높은 것을 먼저 선택해 블록에 포함시킨다. 간단하게 트랜잭션과 블록 생성 과정을 알아보았다.

네트워크 상의 거래 내역을 보존하기 위해서 블록은 상위 블록에 대한 참조가 필요하게끔 정렬되어 결합한다고 앞서 언급했다. 그렇다면 블록은 어떤 방식으로 결합되는 것일까? 새로운 트랜잭션은 블록체인에서 나온 새로운 기록이라고 할 수 있다. 검증자들은 무작위로 트랜잭션을 블록에 담을 수 있는 권한을 부여받는데 이를 블록 제안자(proposer)라고 하고, 트랜잭션을 블록에 담아 공유하면 수많은 검증자(validator)들은 블록 안의 트랜잭션을 검증하고 새로운 블록을 기존의 블록에 추가하여 저장한다. 그 후 다음 블록을 생성할 새로운 검증자가 선택되어 새 블록을 생성한다. 정확한 블록 결합의 과정과 합의 프로세스는 현재 이더리움의 지분증명 프로토콜에 따라 지정된다.